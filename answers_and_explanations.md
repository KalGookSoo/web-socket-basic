# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차
- [Chapter 01 서비스 워커 소개](#chapter-01-서비스-워커-소개)
  - [01-1 서비스 워커란 무엇인가](#01-1-서비스-워커란-무엇인가)
  - [01-2 서비스 워커의 특징](#01-2-서비스-워커의-특징)
  - [01-3 서비스 워커 지원 환경](#01-3-서비스-워커-지원-환경)

## Chapter 01 서비스 워커 소개

### 01-1 서비스 워커란 무엇인가

#### 문제 1
**문제**: 서비스 워커의 주요 역할이 아닌 것은?

**정답**: DOM 직접 조작

**해설**: 서비스 워커는 웹 페이지와 별도로 백그라운드에서 실행되는 JavaScript 워커로, DOM에 직접 접근할 수 없습니다. 서비스 워커는 네트워크 요청 가로채기, 리소스 캐싱, 푸시 알림 처리와 같은 기능을 수행할 수 있지만, DOM 조작은 메인 스레드에서만 가능합니다. 서비스 워커가 DOM과 상호작용하려면 postMessage() 메서드를 통해 메인 스레드와 통신해야 합니다.

#### 문제 2
**문제**: 서비스 워커와 웹 워커의 차이점으로 올바른 것은?

**정답**: 서비스 워커는 네트워크 요청을 가로챌 수 있지만, 웹 워커는 그렇지 않다

**해설**: 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 기능을 가지고 있어 오프라인 지원, 캐싱 전략 구현 등이 가능합니다. 반면, 웹 워커는 CPU 집약적인 작업을 메인 스레드와 별도로 처리하기 위한 목적으로 설계되었으며, 네트워크 요청을 가로채는 기능은 없습니다. 또한 서비스 워커는 페이지와 독립적인 생명주기를 가지며 여러 탭과 창에 걸쳐 작동할 수 있지만, 웹 워커는 생성한 페이지에 종속되어 있습니다.

#### 문제 3
**문제**: 웹 개발자가 서비스 워커를 사용하는 주요 이유로 올바른 것을 모두 고르세요.

**정답**: 오프라인 웹 경험 제공, 네트워크 요청 최적화, 푸시 알림 구현

**해설**: 
- 오프라인 웹 경험 제공: 서비스 워커는 리소스를 캐싱하여 인터넷 연결이 없거나 불안정한 상황에서도 웹 애플리케이션이 작동할 수 있게 합니다.
- 네트워크 요청 최적화: 서비스 워커는 네트워크 요청을 가로채고 캐시된 응답을 제공하거나 네트워크 요청을 수정하여 성능을 최적화할 수 있습니다.
- 푸시 알림 구현: 서비스 워커는 웹 푸시 API와 함께 사용하여 사용자에게 푸시 알림을 보낼 수 있습니다.
- 서버 부하 감소: 이는 서비스 워커의 직접적인 목적이라기보다는 캐싱과 네트워크 최적화의 부수적인 효과입니다.
- DOM 직접 조작: 서비스 워커는 DOM에 직접 접근할 수 없으므로 이는 올바르지 않습니다.

### 01-2 서비스 워커의 특징

#### 문제 1
**문제**: 서비스 워커가 메인 스레드와 별도로 실행되는 이유로 가장 적절한 것은?

**정답**: UI 블로킹을 방지하고 백그라운드 작업을 수행하기 위해

**해설**: 서비스 워커는 메인 스레드와 별도의 워커 스레드에서 실행됩니다. 이는 UI 블로킹을 방지하고 백그라운드 작업을 수행할 수 있게 하는 중요한 특성입니다. 메인 스레드는 DOM 조작과 사용자 인터페이스 처리를 담당하는데, 서비스 워커가 별도의 스레드에서 실행됨으로써 네트워크 요청 처리, 캐싱, 푸시 알림 등의 작업이 메인 스레드를 차단하지 않고 백그라운드에서 효율적으로 수행될 수 있습니다.

#### 문제 2
**문제**: 서비스 워커의 프록시 역할에 대한 설명으로 올바르지 않은 것은?

**정답**: 서버의 부하를 직접 모니터링할 수 있다

**해설**: 서비스 워커는 웹 애플리케이션과 네트워크 사이에서 프록시 역할을 하며, 네트워크 요청을 가로채고 수정할 수 있고, 다양한 캐싱 전략을 구현할 수 있으며, 오프라인 상태에서도 캐시된 응답을 제공할 수 있습니다. 그러나 서비스 워커는 클라이언트 측 기술로, 서버의 부하를 직접 모니터링하는 기능은 없습니다. 서버 부하 모니터링은 서버 측 도구나 별도의 모니터링 서비스를 통해 수행해야 합니다.

#### 문제 3
**문제**: 서비스 워커에서 사용되는 이벤트가 아닌 것은?

**정답**: click

**해설**: 서비스 워커는 install, activate, fetch, push, sync, message 등의 이벤트를 처리할 수 있습니다. 그러나 click 이벤트는 DOM 이벤트로, 서비스 워커에서 직접 처리할 수 없습니다. 서비스 워커는 DOM에 접근할 수 없기 때문에 click과 같은 사용자 인터페이스 이벤트는 메인 스레드에서 처리되어야 합니다. 서비스 워커가 이러한 이벤트에 반응하려면 메인 스레드에서 postMessage()를 통해 메시지를 전송해야 합니다.

#### 문제 4
**문제**: 서비스 워커의 비동기적 특성에 관한 설명으로 올바른 것은?

**정답**: 서비스 워커는 Promise 기반의 API를 주로 사용한다

**해설**: 서비스 워커는 본질적으로 비동기적인 특성을 가지고 있으며, Promise 기반의 API를 주로 사용합니다. 서비스 워커 등록(register()), 캐시 작업(caches.open(), cache.add() 등), 네트워크 요청(fetch()) 등 대부분의 서비스 워커 API는 Promise를 반환합니다. 이러한 비동기적 특성은 작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있게 하여 성능을 향상시키고 효율적인 리소스 사용을 가능하게 합니다.

#### 문제 5
**문제**: 서비스 워커가 HTTPS를 요구하는 이유로 가장 적절한 것은?

**정답**: 보안상의 이유로 중간자 공격을 방지하기 위해

**해설**: 서비스 워커는 네트워크 요청을 가로채고 수정할 수 있는 강력한 기능을 가지고 있기 때문에, 보안상의 이유로 HTTPS 환경에서만 작동하도록 설계되었습니다. HTTPS는 통신 내용이 제3자에 의해 가로채지거나 변조되는 중간자 공격을 방지하고, 웹사이트의 신원을 확인할 수 있게 합니다. 이를 통해 서비스 워커의 강력한 기능이 악의적인 목적으로 사용되는 것을 방지하고, 사용자의 데이터와 프라이버시를 보호할 수 있습니다. 개발 목적으로는 localhost나 127.0.0.1과 같은 로컬 환경에서는 HTTPS 없이도 서비스 워커를 사용할 수 있습니다.

### 01-3 서비스 워커 지원 환경

#### 문제 1
**문제**: 서비스 워커 지원 여부를 확인하는 올바른 JavaScript 코드는?

**정답**: if ('serviceWorker' in navigator) { ... }

**해설**: 서비스 워커 지원 여부를 확인하는 표준적인 방법은 'serviceWorker' 속성이 navigator 객체에 존재하는지 확인하는 것입니다. 이 코드는 브라우저가 서비스 워커를 지원하는 경우에만 조건문 내부의 코드를 실행합니다. 다른 옵션들은 유효한 JavaScript 구문이 아니거나(browser.supportsServiceWorker()), 서비스 워커 지원 여부를 올바르게 확인하지 못합니다(window.serviceWorker, document.serviceWorker). 이러한 기능 감지 패턴은 점진적 향상 기법을 구현할 때 중요한 역할을 합니다.

#### 문제 2
**문제**: 서비스 워커를 지원하지 않는 브라우저에서 사용할 수 있는 대체 기술이 아닌 것은?

**정답**: WebSocket API

**해설**: WebSocket API는 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 기술로, 서비스 워커의 대체 기술이라기보다는 다른 목적을 가진 별개의 웹 API입니다. IndexedDB, LocalStorage, SessionStorage는 모두 클라이언트 측 데이터 저장 메커니즘으로, 서비스 워커의 캐싱 기능을 부분적으로 대체할 수 있습니다. 특히 IndexedDB는 대용량 구조화된 데이터를 저장하는 데 사용될 수 있으며, LocalStorage와 SessionStorage는 간단한 키-값 데이터를 저장하는 데 사용될 수 있습니다.

#### 문제 3
**문제**: 서비스 워커를 사용할 때 권장되는 개발 접근 방식은?

**정답**: 점진적 향상 기법 적용하기

**해설**: 점진적 향상(Progressive Enhancement) 기법은 모든 사용자에게 기본적인 기능을 제공하고, 브라우저가 지원하는 경우에만 추가 기능을 활성화하는 접근 방식입니다. 이 방식을 사용하면 서비스 워커를 지원하지 않는 브라우저에서도 웹 애플리케이션의 핵심 기능이 작동하며, 서비스 워커를 지원하는 브라우저에서는 다음과 같은 향상된 기능을 제공할 수 있습니다:

1. **오프라인 작동**: 인터넷 연결이 없어도 이전에 방문한 페이지와 리소스를 볼 수 있습니다.
2. **성능 향상**: 이미지, 스크립트, 스타일시트 등을 캐시하여 로딩 속도를 개선합니다.
3. **네트워크 복원력**: 불안정한 네트워크 환경에서도 캐시된 콘텐츠를 제공하여 사용자 경험을 유지합니다.
4. **오프라인 대체 콘텐츠**: 네트워크 연결이 없을 때 오프라인 페이지나 대체 이미지를 제공합니다.
5. **백그라운드 동기화**: 오프라인 상태에서 사용자 작업을 저장하고, 온라인 상태가 되면 자동으로 동기화합니다.
6. **푸시 알림**: 웹 애플리케이션이 닫혀 있어도 사용자에게 알림을 보낼 수 있습니다.

예를 들어, 이미지 갤러리 웹 애플리케이션에서는 기본적으로 모든 브라우저에서 이미지를 로드하고 표시하는 기능을 제공하고, 서비스 워커를 지원하는 브라우저에서는 이미지를 캐시하여 오프라인에서도 볼 수 있게 하거나, 네트워크 오류 시 대체 이미지를 제공하는 등의 향상된 기능을 추가할 수 있습니다.

서비스 워커를 지원하는 브라우저만 타겟팅하는 것은 많은 사용자를 배제할 수 있으며, 모든 기능을 폴리필로 구현하는 것은 서비스 워커의 특성상 완전히 불가능합니다. AppCache는 현재 deprecated된 기술로, 서비스 워커와 함께 사용하는 것은 권장되지 않습니다.

